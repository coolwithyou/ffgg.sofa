# Knowledge Pages MVP: 마이크로 블로그 기반 RAG 시스템

## 핵심 컨셉

> **"청크가 아니라 페이지다"**
>
> PDF 100페이지를 블랙박스 청크로 쪼개는 대신, 사람이 읽을 수 있는 구조화된 "지식 페이지"로 변환한다.
> 각 페이지는 동시에 (1) 매뉴얼 사이트의 한 글이자 (2) 챗봇 학습의 한 단위가 된다.

```
┌─────────────────────────────────────────────────────────────────┐
│                        기존 방식                                 │
│  PDF → 청킹 → 벡터DB → 챗봇                                      │
│        (블랙박스)                                                │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                      Knowledge Pages                            │
│  PDF → 지식 페이지 트리 → 사람이 검수/수정 → 배포               │
│                              ↓                                  │
│                    ┌────────┴────────┐                          │
│                    ↓                 ↓                          │
│              매뉴얼 사이트       챗봇 학습                        │
│              (사람용)           (AI용)                           │
└─────────────────────────────────────────────────────────────────┘
```

---

## MVP 목표

### 검증하려는 가설

| # | 가설 | 검증 방법 |
|---|------|-----------|
| 1 | LLM이 PDF를 의미 있는 페이지 단위로 분해할 수 있다 | 실제 고객 문서 3개로 테스트 |
| 2 | 폴더/페이지 구조가 사용자에게 직관적이다 | 내부 테스트 피드백 |
| 3 | 페이지 단위 청킹이 RAG 품질을 유지한다 | 기존 청킹 대비 답변 품질 비교 |
| 4 | 부분 업데이트가 실제로 비용을 절감한다 | 업데이트 시나리오 테스트 |

### MVP 스코프

```
✅ 포함                              ❌ 제외 (Phase 2+)
─────────────────────────────────────────────────────────
PDF → 페이지 트리 변환               정교한 검증 파이프라인
폴더/페이지 트리 UI                  원본 PDF 동기 뷰어
페이지 내용 편집                     정적 사이트 배포
승인 → 벡터 인덱싱                   버전 관리/히스토리
챗봇에서 테스트                      Claim 단위 검증
페이지 단위 업데이트                 협업 워크플로우
```

---

## 데이터 모델

### 핵심 엔티티

```typescript
// 지식 페이지 (= 청크 단위)
interface KnowledgePage {
  id: string;
  datasetId: string;        // 소속 데이터셋
  documentId: string;       // 원본 문서 참조

  // 계층 구조
  parentId: string | null;  // 부모 페이지 (null이면 루트)
  order: number;            // 형제 간 순서
  path: string;             // "installation/requirements"
  depth: number;            // 0, 1, 2...

  // 콘텐츠
  title: string;
  content: string;          // 마크다운
  summary: string;          // AI 생성 요약 (검색용)

  // 원본 추적
  sourcePages: number[];    // PDF 페이지 번호들 [3, 4, 5]
  confidence: number;       // AI 변환 신뢰도 (0-1)

  // 상태
  status: 'draft' | 'review' | 'approved';

  // 메타
  createdAt: Date;
  updatedAt: Date;
  approvedAt: Date | null;
  approvedBy: string | null;
}

// 페이지 임베딩 (벡터 검색용)
interface PageEmbedding {
  pageId: string;
  embedding: number[];

  // 검색 품질 향상용 메타데이터
  breadcrumb: string;       // "설치 가이드 > 시스템 요구사항"
  keywords: string[];       // AI 추출 키워드
}
```

### DB 스키마 (Prisma)

```prisma
model KnowledgePage {
  id          String   @id @default(cuid())
  datasetId   String
  documentId  String

  // 계층 구조
  parentId    String?
  parent      KnowledgePage?  @relation("PageHierarchy", fields: [parentId], references: [id])
  children    KnowledgePage[] @relation("PageHierarchy")
  order       Int      @default(0)
  path        String   // "installation/requirements"
  depth       Int      @default(0)

  // 콘텐츠
  title       String
  content     String   @db.Text
  summary     String?  @db.Text

  // 원본 추적
  sourcePages Int[]    // PDF 페이지 번호들
  confidence  Float    @default(0.8)

  // 상태
  status      PageStatus @default(DRAFT)

  // 관계
  dataset     Dataset  @relation(fields: [datasetId], references: [id], onDelete: Cascade)
  document    Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  // 메타
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  approvedAt  DateTime?
  approvedBy  String?

  @@index([datasetId])
  @@index([documentId])
  @@index([parentId])
  @@index([path])
}

enum PageStatus {
  DRAFT     // AI 생성 직후
  REVIEW    // 검토 중
  APPROVED  // 승인됨 (인덱싱 대상)
}
```

---

## 처리 파이프라인

### 1단계: PDF → 구조 분석

```
PDF 업로드
    ↓
텍스트 추출 (기존 로직 재사용)
    ↓
LLM: 문서 구조 분석
    ↓
페이지 트리 JSON 생성
```

**구조 분석 프롬프트**:

```
당신은 문서 구조화 전문가입니다. 주어진 문서를 계층적인 "지식 페이지" 구조로 분해하세요.

## 목표
- 각 페이지는 하나의 명확한 주제를 다룹니다
- 페이지는 폴더처럼 계층 구조를 가질 수 있습니다
- 각 페이지는 독립적으로 이해 가능해야 합니다

## 페이지 크기 가이드라인
- 너무 짧음: 100단어 미만 (다른 페이지와 합치기)
- 적절함: 200~800단어
- 너무 김: 1000단어 초과 (하위 페이지로 분리)

## 출력 형식

```json
{
  "title": "문서 전체 제목",
  "pages": [
    {
      "id": "overview",
      "title": "개요",
      "source_pages": [1, 2],
      "content_summary": "이 문서가 다루는 내용 요약",
      "children": []
    },
    {
      "id": "installation",
      "title": "설치 가이드",
      "source_pages": [3],
      "content_summary": "설치 방법 안내",
      "children": [
        {
          "id": "requirements",
          "title": "시스템 요구사항",
          "source_pages": [3, 4],
          "content_summary": "필요한 시스템 사양",
          "children": []
        },
        {
          "id": "quick-start",
          "title": "빠른 시작",
          "source_pages": [5, 6],
          "content_summary": "5분 안에 시작하기",
          "children": []
        }
      ]
    }
  ]
}
```

## 문서 내용

{extracted_text}
```

### 2단계: 페이지별 콘텐츠 생성

구조가 결정되면, 각 페이지별로 콘텐츠를 생성:

```
각 페이지에 대해:
    ↓
해당 source_pages의 원문 추출
    ↓
LLM: 마크다운 콘텐츠 생성
    ↓
KnowledgePage 레코드 생성
```

**콘텐츠 생성 프롬프트**:

```
당신은 기술 문서 작성 전문가입니다. 주어진 원문을 깔끔한 마크다운 페이지로 변환하세요.

## 페이지 정보
- 제목: {title}
- 상위 경로: {breadcrumb}
- 이 페이지의 역할: {content_summary}

## 작성 원칙
1. 원문의 모든 정보를 포함하세요 (누락 금지)
2. 구조화된 마크다운을 사용하세요 (헤더, 리스트, 테이블)
3. 원문에 없는 정보를 추가하지 마세요
4. 연락처, 숫자, 날짜는 원문 그대로 유지하세요

## 원문 (PDF 페이지 {source_pages})

{source_text}

## 출력
마크다운 형식의 페이지 콘텐츠만 출력하세요.
```

### 3단계: 검수 및 승인

```
페이지 트리 UI에서 확인
    ↓
필요시 내용 수정 (에디터)
    ↓
[모두 승인] 또는 [개별 승인]
    ↓
승인된 페이지만 벡터 인덱싱
```

### 4단계: 벡터 인덱싱

```typescript
async function indexApprovedPages(datasetId: string) {
  const pages = await db.knowledgePage.findMany({
    where: { datasetId, status: 'APPROVED' }
  });

  for (const page of pages) {
    // 검색 최적화된 텍스트 구성
    const searchText = [
      `# ${page.title}`,
      `경로: ${getBreadcrumb(page)}`,
      page.content,
      page.summary,
    ].join('\n\n');

    const embedding = await embedDocument(searchText);

    await vectorDB.upsert({
      id: page.id,
      embedding,
      metadata: {
        datasetId: page.datasetId,
        documentId: page.documentId,
        pageId: page.id,
        title: page.title,
        path: page.path,
        breadcrumb: getBreadcrumb(page),
      }
    });
  }
}
```

---

## UI 설계

### 메인 화면: 페이지 트리 + 에디터

```
┌──────────────────────────────────────────────────────────────────────────┐
│ 📄 product-manual.pdf                         [모두 승인] [삭제] [취소]  │
├────────────────────────┬─────────────────────────────────────────────────┤
│                        │                                                 │
│  📁 페이지 구조         │  📝 페이지 편집                                  │
│                        │                                                 │
│  ▼ 📖 제품 매뉴얼       │  ┌─────────────────────────────────────────┐   │
│    ├─ 📄 개요      ✅   │  │ # 시스템 요구사항                        │   │
│    ├─ 📁 설치 가이드    │  │                                         │   │
│    │  ├─ 📄 요구사항 ●  │  │ ## 최소 사양                            │   │
│    │  └─ 📄 빠른시작 ⏳ │  │ - Python 3.9 이상                       │   │
│    ├─ 📁 기능 설명      │  │ - Node.js 18 이상                       │   │
│    │  ├─ 📄 대시보드 ⏳ │  │ - 메모리 4GB 이상                       │   │
│    │  └─ 📄 설정    ⏳  │  │                                         │   │
│    └─ 📄 FAQ       ⏳   │  │ ## 권장 사양                            │   │
│                        │  │ - Python 3.11                           │   │
│  ──────────────────    │  │ - Node.js 20 LTS                        │   │
│  ✅ 승인됨: 1           │  │ - 메모리 8GB 이상                       │   │
│  ⏳ 검토 대기: 5        │  │                                         │   │
│  ● 현재 선택           │  └─────────────────────────────────────────┘   │
│                        │                                                 │
│                        │  원본 위치: PDF 3-4페이지                        │
│                        │  신뢰도: 92%                                    │
│                        │                                                 │
│                        │  [이 페이지 승인 ✓]  [수정사항 저장]             │
│                        │                                                 │
├────────────────────────┴─────────────────────────────────────────────────┤
│  💬 챗봇 테스트                                                          │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │ Q: 시스템 요구사항이 뭔가요?                                       │  │
│  │                                                                   │  │
│  │ A: 최소 사양은 Python 3.9 이상, Node.js 18 이상, 메모리 4GB입니다. │  │
│  │    권장 사양은 Python 3.11, Node.js 20 LTS, 메모리 8GB입니다.      │  │
│  │                                                                   │  │
│  │    📖 출처: 설치 가이드 > 시스템 요구사항                          │  │
│  └───────────────────────────────────────────────────────────────────┘  │
│  [___________________________] [테스트]                                  │
└──────────────────────────────────────────────────────────────────────────┘
```

### 상태 아이콘

| 아이콘 | 상태 | 설명 |
|--------|------|------|
| ⏳ | `draft` | AI 생성 직후, 검토 필요 |
| 🔍 | `review` | 검토 중 |
| ✅ | `approved` | 승인됨, 챗봇 학습 완료 |
| ⚠️ | 저신뢰도 | confidence < 0.7 |

### 페이지 편집 기능

1. **마크다운 에디터**: 기본 편집
2. **원본 참조**: "PDF 3-4페이지" 클릭 시 원본 확인 (Phase 2)
3. **AI 재생성**: "이 페이지 다시 생성" 버튼
4. **페이지 분할/병합**: 드래그앤드롭으로 구조 변경

---

## 부분 업데이트 플로우

### 시나리오: 가격 정책 변경

```
1. 사용자가 "pricing" 페이지 선택

2. 내용 수정
   - 기존: "월 $10"
   - 변경: "월 $15"

3. [저장] 클릭
   - KnowledgePage.content 업데이트
   - KnowledgePage.status = 'review'

4. [승인] 클릭
   - KnowledgePage.status = 'approved'
   - 해당 페이지만 재벡터화

5. 완료
   - 다른 99개 페이지는 그대로
   - 비용: 1개 페이지 임베딩 비용만 발생
```

### 구현

```typescript
async function updatePage(pageId: string, content: string) {
  // 1. 페이지 내용 업데이트
  await db.knowledgePage.update({
    where: { id: pageId },
    data: {
      content,
      status: 'REVIEW',
      updatedAt: new Date()
    }
  });
}

async function approvePage(pageId: string, userId: string) {
  // 1. 상태 업데이트
  const page = await db.knowledgePage.update({
    where: { id: pageId },
    data: {
      status: 'APPROVED',
      approvedAt: new Date(),
      approvedBy: userId
    }
  });

  // 2. 해당 페이지만 재인덱싱
  await reindexPage(page);
}

async function reindexPage(page: KnowledgePage) {
  const searchText = buildSearchText(page);
  const embedding = await embedDocument(searchText);

  // 기존 벡터 교체 (upsert)
  await vectorDB.upsert({
    id: page.id,
    embedding,
    metadata: { ... }
  });
}
```

---

## 구현 체크리스트

### Week 1: 기반 구축

#### DB & 모델
- [ ] `KnowledgePage` Prisma 스키마 추가
- [ ] 마이그레이션 실행
- [ ] 기본 CRUD API 구현

#### 문서 처리
- [ ] 구조 분석 프롬프트 작성 및 테스트
- [ ] 콘텐츠 생성 프롬프트 작성 및 테스트
- [ ] PDF → 페이지 트리 변환 함수 구현

### Week 2: UI & 통합

#### UI
- [ ] 페이지 트리 컴포넌트 (사이드바)
- [ ] 마크다운 에디터 (메인 영역)
- [ ] 상태 표시 및 승인 버튼

#### 인덱싱
- [ ] 승인된 페이지 벡터화 로직
- [ ] 부분 업데이트 (재인덱싱) 로직
- [ ] 챗봇 검색에 페이지 메타데이터 활용

#### 테스트
- [ ] 실제 고객 문서로 E2E 테스트
- [ ] 기존 청킹 대비 답변 품질 비교

---

## 기존 시스템과의 통합

### 마이그레이션 전략

```
Phase 1 (MVP): 새 문서만 Knowledge Pages로
- 기존 Document/Chunk 시스템 유지
- 새로 업로드하는 문서에 "Knowledge Pages 모드" 옵션 제공

Phase 2: 점진적 전환
- 기존 문서 → Knowledge Pages 변환 도구 제공
- 사용자가 원할 때 마이그레이션

Phase 3: 완전 전환
- Chunk 테이블 deprecated
- 모든 문서가 Knowledge Pages 기반
```

### 공존 구조

```typescript
// 챗봇 검색 시
async function searchKnowledge(query: string, datasetId: string) {
  // 1. Knowledge Pages 검색
  const pageResults = await searchKnowledgePages(query, datasetId);

  // 2. 기존 Chunk 검색 (레거시)
  const chunkResults = await searchChunks(query, datasetId);

  // 3. 결과 통합 (점수 기반 정렬)
  return mergeResults(pageResults, chunkResults);
}
```

---

## 성공 기준

### MVP 완료 조건

| 기준 | 목표 | 측정 방법 |
|------|------|-----------|
| 변환 성공률 | 90% 이상 | 테스트 문서 10개 중 9개 성공 |
| 사용자 만족도 | 긍정 피드백 | 내부 테스트 3명 중 2명 이상 |
| RAG 품질 유지 | 기존 대비 동등 이상 | 동일 질문 세트로 비교 |
| 부분 업데이트 | 정상 작동 | 1개 페이지 수정 → 해당 청크만 갱신 확인 |

### 품질 비교 테스트 방법

```
1. 테스트 문서 선정 (고객 실제 문서 3개)

2. 각 문서에 대해:
   a. 기존 방식으로 청킹 → 인덱싱
   b. Knowledge Pages로 변환 → 인덱싱

3. 테스트 질문 10개 준비

4. 두 방식으로 각각 답변 생성

5. 평가:
   - 정확성 (1-5점)
   - 완전성 (1-5점)
   - 출처 명확성 (1-5점)
```

---

## 리스크 및 대응

| 리스크 | 확률 | 영향 | 대응책 |
|--------|------|------|--------|
| LLM 구조 분석 실패 | Medium | High | 폴백: 페이지 단위 기본 분할 |
| 페이지가 너무 길거나 짧음 | High | Medium | 가이드라인 + 수동 조정 UI |
| 계층 구조가 부자연스러움 | Medium | Medium | 드래그앤드롭 재구성 기능 |
| 기존 시스템과 충돌 | Low | High | 공존 모드로 점진적 전환 |

---

## 다음 단계 (Phase 2 Preview)

MVP 검증 후 추가할 기능:

1. **원본 PDF 동기 뷰어**: 페이지 ↔ PDF 위치 연동
2. **의심 항목 하이라이트**: 기존 전략의 검증 파이프라인 통합
3. **정적 사이트 배포**: 승인된 페이지를 퍼블릭 매뉴얼 사이트로
4. **버전 관리**: 페이지별 변경 이력 + 롤백
5. **협업 기능**: 검토 요청, 코멘트, 승인 워크플로우

---

*문서 버전: 1.0*
*작성일: 2026-01-11*
*상태: MVP 설계 완료, 구현 대기*
